<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MADNESS: Thinking in MADNESS</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MADNESS<span id="projectnumber">&#160;0.10.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle"><div class="title">Thinking in MADNESS<div class="ingroups"><a class="el" href="group__getting__started.html">Getting started with MADNESS</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Thinking in MADNESS:</div>
<div class="dyncontent">
<div class="center"><img src="group__gstart__think__madness.png" border="0" usemap="#agroup____gstart____think____madness" alt=""/></div>
<map name="agroup____gstart____think____madness" id="agroup____gstart____think____madness">
<area shape="rect" href="group__getting__started.html" title=" " alt="" coords="5,5,157,45"/>
<area shape="rect" title=" " alt="" coords="205,13,368,38"/>
</map>
</div>
<p>MADNESS is based on multiresolution analysis (MRA) and low-separation rank (LSR) approximations of functions and operators. It can be considered an adaptive spectral element method using a discontinuous and singular multiresolution basis. The representations of differential operators in the wavelet bases are provably similar to adaptive finite difference discretizations. Thus, the process of solving the resulting linear systems has similar behaviors to other adaptive methods. For example, the derivative operator and the Laplacian operator are unbounded operators. Thus the condition number, which often constrains how accurately the linear system can be solved, goes to infinity as the bases or the nets are refined. In order to solve these equations in practice, one has to precondition the system. Effective preconditioners are problem dependent and the theory of their construction is an area of on-going research.</p>
<p>The integral operator, which is the formal inverse associated with the differential operator, is usually bounded. MRA and LSR have been proven to be suitable techniques for effectively applying some of the physically important operators and their kernel fast and with ease.</p>
<p>Two of the most important operators that we illustrate in this manual are the Poisson operator, and the Helmholtz operator (also note that heat/diffusion equation kernel is just a single <a class="el" href="classGaussian.html">Gaussian</a>).</p>
<p>Herein, we discuss techniques for "thinking in MADNESS", which will allow the best utilization of the numerical tools underlying MADNESS (in most cases).</p>
<dl class="section user"><dt>Solve the integral equation</dt><dd></dd></dl>
<p>In many situations the integral operator associated with the differential operator has an analytic kernel. The simplest examples are convolution operators.</p><ul>
<li>The free-space Poisson equation is converted to a convolution with the Poisson (or Coulomb) kernel,  <p class="formulaDsp">
<picture><source srcset="form_29_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
\nabla^{2} u = -4\pi\rho \to u=G \ast \rho,
\]" src="form_29.png"/></picture>
</p>
 where <picture><source srcset="form_30_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$G(r-r')=\frac{1}{|r-r'|}$" src="form_30.png"/></picture>.</li>
<li>The Schr&ouml;dinger equation with potential <picture><source srcset="form_31_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$V$" src="form_31.png"/></picture> is converted to a Lippman-Schwinger equation using the bound-state Helmholtz kernel,  <p class="formulaDsp">
<picture><source srcset="form_32_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
- \frac{1}{2} \nabla^{2} \psi + V\psi = E \psi \to \psi = -2G \ast V\psi,
\]" src="form_32.png"/></picture>
</p>
 where <picture><source srcset="form_33_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$G(r-r')=\frac{e^{-\sqrt{-2E|r-r'|}}}{4\pi |r-r'|} $" src="form_33.png"/></picture>.</li>
<li>Duhamel's principle can be appled to write a time-dependent differential equation with linear operator <picture><source srcset="form_34_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat{L}$" src="form_34.png"/></picture> and a non-linear operator <picture><source srcset="form_35_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$N$" src="form_35.png"/></picture> as a semi-group equation.  <p class="formulaDsp">
<picture><source srcset="form_36_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
\hat{L}u + N(u,t) = \dot{u} \to u(t) = e^{\hat{L} t} u(0) + \int _{0}^{t} e^{\hat{L} (t-t')} N(u,t') \mathit{d}t'.
\]" src="form_36.png"/></picture>
</p>
</li>
</ul>
<p>Most codes, including MADNESS, are bad at solving differential equations to high accuracy &ndash; this is why there is so much emphasis placed on finding a good preconditioner. The problem arises from the spectrum of the differential operator. Consider the Laplacian in 1<a class="el" href="structD.html">D</a> acting on a plane wave,  </p><p class="formulaDsp">
<picture><source srcset="form_37_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
\frac{d^{2}}{\mathit{dx}^{2}}e^{i\omega x}=-\omega ^{2}e^{i\omega x}.
\]" src="form_37.png"/></picture>
</p>
<p> The Laplacian greatly amplify high frequencies <picture><source srcset="form_38_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\omega$" src="form_38.png"/></picture> (where most of the numerical error lies), whereas physical applications are primarily interested in lower frequencies. The eigenvalues of the corresponding inverse or integral operator have the opposite effect &ndash; high frequencies are suppressed and lower frequencies are emphasized.</p>
<p>The integral form is potentially better in many ways &ndash; accuracy, speed, robustness, asymptotic behavior, etc. If you really, really, want to solve the differential form, then instead of using the phrase "integral form" say "perfectly preconditioned differential form" so that you can do the right thing.</p>
<dl class="section user"><dt>Carefully analyze discontinuities, noise, singularities, and asymptotic forms</dt><dd></dd></dl>
<p>Your function needs to be evaluated at close to machine precision. The higher the order of the basis ( <picture><source srcset="form_7_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$k$" src="form_7.png"/></picture>) the greater the necessary accuracy, regardless of what threshold you are trying to compute to. The accuracy and convergence of the Gauss-Legendre quadrature rests on the function being smooth (well approximated by a polynomial) at some level of refinement. Discontinuities in the function value or its derivatives, singularities, and/or numerical noise can all cause excessive refinement as MADNESS tries to deliver the requested precision. It's the Gibbs effect in action. <em>The usual symptoms of this problem are unexpectedly slow execution and/or excessive memory use.</em> Here are some tips to work with these effects.</p>
<p>Discontinuities and singularities need to be consciously managed. Integrable point singularities might sometimes work unmodified (e.g., <picture><source srcset="form_39_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$1/r$" src="form_39.png"/></picture> in 3-<a class="el" href="structD.html">D</a>) but can unpredictably fail, e.g., if a quadrature point lands very near to the singularity by accident. If possible, arrange for such points/surfaces to coincide with dyadic points (i.e., an integer multiple of some power of two division of the domain) &ndash; this will give the most accurate representation and exploits the discontinuous spectral basis. If you cannot ensure such placement, you must manually or analytically regularize the function. One would usually employ a parameter to control the length scale of any problem modification and to enable systematic demonstration of convergence. E.g., eliminate the cusp in an exponential with  </p><p class="formulaDsp">
<picture><source srcset="form_40_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
\exp(-r) \to \exp (-\sqrt{r^{2}+\sigma ^{2}}),
\]" src="form_40.png"/></picture>
</p>
<p> or replace a step function with  </p><p class="formulaDsp">
<picture><source srcset="form_41_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
\theta(x) \to \theta(x, \lambda) = \frac{1}{2} (1 + \tanh\frac{x}{\lambda}),
\]" src="form_41.png"/></picture>
</p>
<p> or the Coulomb potential in 3-<a class="el" href="structD.html">D</a> with  </p><p class="formulaDsp">
<picture><source srcset="form_42_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
\frac{1}{r} \to u(r,c) = \frac{1}{r} \mathrm{erf} \frac{r}{c} + \frac{1}{c\sqrt{\pi}} e^{-\left( \frac{r}{c} \right)^{2}}
\]" src="form_42.png"/></picture>
</p>
<p> subject to  </p><p class="formulaDsp">
<picture><source srcset="form_43_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
\int_{0}^{\infty} \left(u(r, c) - r^{-1}\right) r^{2} d\mathit{r} = 0.
\]" src="form_43.png"/></picture>
</p>
<p> The integral indicates that the mean error is zero, independent of <picture><source srcset="form_44_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$c$" src="form_44.png"/></picture>.</p>
<p>Numerical noise can be a problem if your function is evaluated using interpolation or some other approximation scheme, or when switching between representations (e.g., between forms suitable for small or large arguments). If you are observing inefficient projection into the basis, ensure that your approximation is everywhere smooth to circa 1 part in <picture><source srcset="form_45_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$10^{12}$" src="form_45.png"/></picture> or better.</p>
<p>MADNESS itself computes to a finite precision, and when computing a point-wise function of a function (i.e., <picture><source srcset="form_46_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$g(f(x))$" src="form_46.png"/></picture>, where <picture><source srcset="form_47_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$f(x)$" src="form_47.png"/></picture> is a MADNESS function and <picture><source srcset="form_48_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$g(s)$" src="form_48.png"/></picture> is a user-provided function), the user-provided function must tolerate that approximation within tolerance or noise. <a class="el" href="classA.html">A</a> classic example is computing the function  </p><p class="formulaDsp">
<picture><source srcset="form_49_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
V(\rho(x)) = \frac{C}{\rho^{1/3}(x)},
\]" src="form_49.png"/></picture>
</p>
<p> where in the original problem one knows that <picture><source srcset="form_50_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\rho (x)&gt;0$" src="form_50.png"/></picture> for all <picture><source srcset="form_3_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$x$" src="form_3.png"/></picture> but numerically this positivity not guaranteed. In this case an effective smoothing is  </p><p class="formulaDsp">
<picture><source srcset="form_51_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\begin{eqnarray*}
V(\rho) &amp; \to &amp; V(S(\rho)) \\
S(s) &amp; = &amp; \left\{ \begin{array}{ll} s_{0}, &amp; s\le 0 \\ q(s, s_{0}, s_{1}), &amp; 0 &lt; s \le s_{1} \\ s, &amp; s &gt; s_{1} \end{array} \right. \\
q(s, s_{0}, s_{1}) &amp; = &amp; s_{0} - (-2s_{1} + 3s_{0}) \left( \frac{s}{s_{1}} \right)^{2} + (2s_{0} - s_{1}) \left(\frac{s}{s_{1}}\right)^{3}.
\end{eqnarray*}" src="form_51.png"/></picture>
</p>
<p> The function <picture><source srcset="form_52_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$S(s)$" src="form_52.png"/></picture> coincides with its argument for <picture><source srcset="form_53_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$s&gt;s_{1}$" src="form_53.png"/></picture> and, for smaller values, smoothly switches to a minimum value of <picture><source srcset="form_54_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$s_{0}$" src="form_54.png"/></picture> with a continuous value and derivative at both end points.</p>
<p>Some computations are intrinsically expensive. For instance, the function <picture><source srcset="form_55_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \exp(i\omega r)$" src="form_55.png"/></picture> is oscillatory everywhere and the number of required coefficients will increase linearly with the solution volume. In a 3-<a class="el" href="structD.html">D</a> box of width <picture><source srcset="form_56_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$L$" src="form_56.png"/></picture>, the number of coefficients will be <picture><source srcset="form_57_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\mathcal{O}\left(\left(Lk\omega \right)^{3}\right)$" src="form_57.png"/></picture> (where <picture><source srcset="form_7_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$k$" src="form_7.png"/></picture> is the multiwavelet or polynomial order). For <picture><source srcset="form_58_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$L=1000$" src="form_58.png"/></picture>, <picture><source srcset="form_59_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$k=12$" src="form_59.png"/></picture> and <picture><source srcset="form_60_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\omega=3$" src="form_60.png"/></picture>, a few hundred TB of data (i.e., too much!) will be generated. Thus, it is worth making a back of the envelope estimate about the expected cost of computation before getting started.</p>
<p>Choice of polynomial order ( <picture><source srcset="form_7_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$k$" src="form_7.png"/></picture>) depends upon the problem and algorithm. Smooth functions can be very accurately and efficiently represented using high-order polynomials, so it can be advantageous to use <picture><source srcset="form_61_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$k=10$" src="form_61.png"/></picture> or higher (for some time-dependent problems we have even used <picture><source srcset="form_62_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$k=30$" src="form_62.png"/></picture>). However, functions with fine-scale structure or cusps or discontinuities require adpative refinement so lower order polynomials (e.g., <picture><source srcset="form_63_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$k=6$" src="form_63.png"/></picture>) are more efficient. If you are using integral operators, increasing the polynomial order as you increase the accuracy maintains sparsity in the operator, which is why in <code>moldft</code> we use the heuristic that to get an accuracy of <picture><source srcset="form_1_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$10^{-n}$" src="form_1.png"/></picture> we use <picture><source srcset="form_2_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$k=n+2$" src="form_2.png"/></picture>.</p>
<p>Previous: <a class="el" href="group__gstart__load__balance.html">Load and memory balancing</a>; Next: <a class="el" href="group__gstart__env__var.html">MADNESS environment variables</a> </p>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 28 2025 18:18:37 for MADNESS by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
